#
# WineDbg test - stack & frame scoping
#
# Copyright (C) 2005 Eric Pouech
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# TODO
# - extend frame tests with register variables
#   (but how to create them in a portable manner ?)
# - test passing structures on the stack (it's ABI dependent)
# - test returning structures from a function (it's ABI dependent)

START "wdtp_$flavor$" "stack"
	BREAK "b wdtp_test_stack_func : 10" 1

	COMMAND "cont"

	BACKTRACE
	CHECK_FRAME 0 "wdtp_test_stack_func" "wdtp_stack.c" 10 "i=10"

	CHECK_FRAME 1 "wdtp_test_stack_func" "wdtp_stack.c" 7 "i=9"
	CHECK_FRAME 2 "wdtp_test_stack_func" "wdtp_stack.c" 7 "i=8"
	CHECK_FRAME 3 "wdtp_test_stack_func" "wdtp_stack.c" 7 "i=7"
	CHECK_FRAME 4 "wdtp_test_stack_func" "wdtp_stack.c" 7 "i=6"
	CHECK_FRAME 5 "wdtp_test_stack_func" "wdtp_stack.c" 7 "i=5"
	CHECK_FRAME 6 "wdtp_test_stack_func" "wdtp_stack.c" 7 "i=4"
	CHECK_FRAME 7 "wdtp_test_stack_func" "wdtp_stack.c" 7 "i=3"
	CHECK_FRAME 8 "wdtp_test_stack_func" "wdtp_stack.c" 7 "i=2"
	CHECK_FRAME 9 "wdtp_test_stack_func" "wdtp_stack.c" 7 "i=1"

	CHECK_FRAME 10 "wdtp_test_stack_float" "wdtp_stack.c" 19 "i=1, f=1.234500, d=-1.456700"
	CHECK_FRAME 11 "test_stack" "wdtp_stack.c" 24 "argc=0, argv=..."
	CHECK_FRAME 12 "main" "wdtp.c" 12 "argc=2, argv=..."

	# testing local variables
	EVAL "p i" mv_integer 10

	COMMAND "up"
	EVAL "p i" mv_integer 9
	EVAL "set i=45" mv_null 0

	COMMAND "up 3"
	EVAL "p i" mv_integer 6

	COMMAND "down 2"
	EVAL "p i" mv_integer 8

	COMMAND "down"
	EVAL "p i" mv_integer 45
END
